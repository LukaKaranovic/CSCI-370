# Scheduler Protocols
1. Lock based protocols
2. Timestamp based protocols
3. Optimistic protocols
# Lock based protocols
Two kinds of locks:
- Shared lock - for read operations only
- Exclusive lock - for read and write operations, especially for write

**SLi(x)** - Ti requests a **shared lock** on element x. 
**XLi(x)** - Ti requests an **exclusive lock** on x. 
**Ui(x)** - Ti releases (**unlocks**) whatever lock it has on x.

**Consistency of Transactions:** Actions and locks must relate to each other in these ways:
- A transaction can only read or write an element if it previously was granted a proper lock on that element and has not yet released the lock. 
- If a transaction locks an element, it must later unlock that element.

**Legality of Schedules:** Locks must have their intended meaning: 
- An element may **either** be locked **exclusively by one transaction**.
- Or locked in **shared mode by one or many transactions**
- An element can not be locked in both modes.

**How it works:**
1. Get a lock on a DB object x
2. Perform operation on x
3. Release lock on x
## Two phase locking (2PL)
 **In every transaction, all lock actions precede all unlock actions.**
- Once a transaction releases a lock, it's not allowed to acquire any locks
	- Can't release a lock and then acquire more locks
- Using 2PL, it is **guaranteed** that the **schedule generated** by the scheduler is **conflict serializable** (not recoverable or cascaseless though).

**Why does 2PL work?**
- It is not possible for a sequence R1(x) W1(x) R2(x) to occur:
	- Transaction 1 has a shared lock on X
	- Transaction 1 therefore can't apply an exclusive lock on X unless transaction 1 unlocks
	- If transaction 1 unlocks, then transaction 1 can't apply the exclusive lock as it has released a lock so it can't acquire new ones.
	
**Strict two phase locking (2PL) protocol**
- Transaction holds all locks until the end of the transaction
	- releases all locks at once
- It is guaranteed that the schedule generated by the scheduler is conflict serializable and cascadeless.

**2PL visualization:**
![[Pasted image 20250404134026.png]]
![[Pasted image 20250404134049.png]]



- Ri(x) (if Wi(x), put exclusive lock instead of shared)
	- scheduler requests lock manager to try and put a shared lock on x on behalf of Ti
		- if successful, then we can execute Ri(x)
		- if failed, delay Ri(x)
- Ai / Ci
	- release all locks held by Ti

Note: **lock manager** - part of scheduler or external element
- scheduler calls lock manager to do lock operations

### Deadlocking
How does lock manager help avoid deadlocking?
1. **detect** deadlocks **and recover** from them
	- to detect, we can draw a wait-for graph
	- if the graph is cyclic, we have a deadlock
		- abort a transaction to break the cycle, then make that transaction restart
2. **prevent** deadlocks from happening in the first place
	- order resource objects
		- if x is ahead of y, there's no way you can request a lock on x after you put a lock on y
	- tree lock protocol
	- order transactions
		- look at timestamp of transactions, order them based on those timestamps

**Wait-die**
T1 requests a lock that must be released by T2
- if T1 older than T2
	- Wait-die: T1 waits
	- Wound-wait: T2 abort
- if T1 younger than T2
	- Wait-die: T1 dies/aborts
	- Wound-wait: T1 wait
## Timestamp based protocol
- each transaction has a timestamp TS(T)
- each DB object x has:
	- read timestamp RT(x) - which transaction last read this object?
	- write timestamp WT(x) - which transaction last wrote into this object?
	- commit bit C(x)
		- 1 means x currently holds dirty data
		- 0 means x holds clean data

Protocol rules:
- T requests to read x
	- if TS(T) >= WT(x), it's realizable
		- if C(x) is true, execute:
			- read x
			- RT(x) = max(TS(T), RT(x))
		- else: delay
	- if TS(T) < WT(x), it's physically unrealizable
		- reject, abort T

- T requests to write x
	- if TS(T) >= RT(x) and TS(T) >= WT(x), it's realizable
		- update x
		- WT(x) = TS(T)
		- C(x) = false
	- else if TS(T) >= RT(x) and TS(T) < WT(x)
		- if C(x) is true: ignore
		- else: delay
	- else // TS(T) < RT(x), unrealizable
		- reject, abort T

- T wants to commit
	- set C(x) to true if WT(x) = TS(T)

- T wants to rollback
	- any transaction waiting on x that T wrote must repeat its read/write request
## Optimistic protocol


## Phantom Problem
![[Pasted image 20250327140611.png]]

## SQL Isolation Levels
You can tell your DBMS how you would like your transaction be treated. 
`set transaction [read only | read write] isolation level [read uncommitted | read committed | repeatable read | serializable];`
- ![[Pasted image 20250327141124.png]]